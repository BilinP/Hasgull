-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/BilinP/Hasgull/blob/main/README.md</a>
@package Hasgull
@version 0.1.0.0


-- | This documentation page addresses several questions regarding the
--   design of the Hasgull language.
--   
--   <h1>A short explanation of what the language is</h1>
--   
--   Somewhat Haskell-like language with a form of typeclassing. Users can
--   create abstract functions and then later implement them for types,
--   these can be our primitives, such as Int, Boolean, or Void, or it can
--   be a user-defined struct. Functions can have the same names but are
--   different.
--   
--   <h1>How do I compile your compiler?</h1>
--   
--   To compile, you'll need to use Stack. First, run <b>stack build</b> to
--   build the project (if necessary). Pretty much no other special setup
--   is needed. Other then installing the current version of Stack and
--   Haskell. You can find the installation instructions for Stack at
--   <a>https://docs.haskellstack.org/en/stable/README/</a> abnd the
--   Haskell installation instructions at
--   <a>https://www.haskell.org/downloads/</a>.
--   
--   <h1>How do I run your compiler?</h1>
--   
--   Then use <b>stack exec Hasgull-exe firstarg secondarg</b> to run the
--   compiler. The compilation process will only begin if firstarg is a
--   file with the .gull extension and exactly two command-line arguments
--   are provided. The second argument is the name of the output file. The
--   compiler will generate a JavaScript file with the same name as the
--   second argument, but with a .js extension.
--   
--   Example wrong usage:
--   
--   <pre>
--   stack exec Hasgull-exe test.py ant 
--   </pre>
--   
--   This will fail since test.py is not a .gull file.
--   
--   <pre>
--   stack exec Hasgull-exe sample.gull output flag 
--   </pre>
--   
--   This will fail since there are too many arguments.
--   
--   Example correct usage:
--   
--   <pre>
--   stack exec Hasgull-exe sample.gull output
--   </pre>
--   
--   This will create a file named output.js with the compiled JavaScript
--   code. where if you have Node.js installed, you can run the output file
--   with:
--   
--   <pre>
--   node {output.js} (file name)
--   </pre>
--   
--   <h1>How do I run your tests?</h1>
--   
--   To run the test cases (already defined in our code) for each component
--   of our compiler in our code, you can use pattern matching for that
--   specific test part:
--   
--   For Tokenizer
--   
--   <pre>
--   stack test-arguments="--pattern=Tokenizer"
--   </pre>
--   
--   For Parser
--   
--   <pre>
--   stack test --test-arguments="--pattern=Parser"
--   </pre>
--   
--   Code Generation
--   
--   <pre>
--   stack test --test-arguments="--pattern=Generation"
--   </pre>
--   
--   Or to just run them all
--   
--   <pre>
--   stack test 
--   </pre>
--   
--   Each stage builds upon the previous one. For example, the Parser
--   depends on the Tokenizer to produce tokens before parsing, and Code
--   Generation depends on both the Tokenizer and the Parser to generate
--   the final output.
--   
--   <h1>Code snippets in your language highlighting features and edge
--   cases, along with relevant explanations</h1>
--   
--   For example, to demonstrate our typeclass system, which works
--   similarly to Java's interface mechanism, we define a base trait with a
--   method called add that takes another value of the same type and
--   returns a result of that type. Then we use an impl block for a
--   specific type to define the actual method implementation. Structs can
--   also be used as valid types in this system, following the same trait
--   and impl. We also have functions that take parameters and return
--   values
--   
--   <pre>
--   trait Addable {
--   method add(other: Self): Self;
--   }
--   trait Printable {
--   method print(): Void;
--   }
--   struct IntWrapper {
--   value: Int
--   }
--   impl Addable for Int {
--   method add(other: Int): Int {
--   return self + other;
--   }
--   }
--   
--   
--   impl Addable for IntWrapper {
--   method add(other: IntWrapper): IntWrapper {
--   return new IntWrapper { value: self.value + other.value };
--   }
--   
--   }
--   
--   impl Printable for Boolean {
--       method print(): Void{
--           println(1);
--       }
--   }
--   
--   impl Printable for Int {
--   method print(): Void {
--   println(self);
--   }
--   }
--   
--   impl Printable for IntWrapper {
--   method print(): Void {
--   println(self.value);
--   }
--   }
--   
--   func bob(a: Int, x:Int): Int {
--       if( a &lt; x){
--           return a;
--       } else{
--           return x;
--       }
--   
--   }
--   </pre>
--   
--   Which then compiles into this.
--   
--   <pre>
--   class IntWrapper {
--     constructor(value) {
--       this.value = value;
--     }
--   }
--   
--   Number.prototype.add = function(other) {return this+other; };IntWrapper.prototype.add = function(other) {return new IntWrapper(this.value+other.value); };Boolean.prototype.print = function() {console.log(1);};Number.prototype.print = function() {console.log(this);};IntWrapper.prototype.print = function() {console.log(this.value);};function bob(a, x) {if( a&lt;x) {return a; } else {return x; }}
--   </pre>
--   
--   The javascript output is messy, but if the programmer really cares
--   about that, then they can clean it up on their own time or easily
--   format the code .
--   
--   However, we do somewhat have a checker if the user actually created a
--   trait to be later given definition with impl for a type. If you just
--   do impl Addable for Int { ……} and try to compile. It will spit out
--   out:
--   
--   <pre>
--   Hasgull-exe.EXE: Unknown trait: Addable
--   CallStack (from HasCallStack):
--   </pre>
--   
--   If statement in between a while stmt that compiles into javascript.
--   
--   <pre>
--   INPUT:
--   while(x &lt; 5){
--       a3 = a3 + 5;
--       println(a3);
--       if(a3 == 17){
--           break;
--       }
--       x = x + 1;
--   }
--   
--   OUTPUT:
--   while(x&lt;5) {a3=a3+5;  console.log(a3); if( a3===17) {break;} x=x+1; }
--   </pre>
--   
--   You can do binary expressions with different types and will compile,
--   but what happens after is really up to javascript.
--   
--   <pre>
--   INPUT (with the above code for typeclasses):
--   
--   let a5: Boolean = true;
--   let a2: IntWrapper = new IntWrapper { value: 7 };
--   let a3: Int = a1.add(2);
--   let a4: IntWrapper = a2.add(new IntWrapper { value: 3 });
--   a3.print();
--   a4.print();
--   a5=a5+a1
--   
--   OUTPUT:
--   let a5 = true;let a2 = new IntWrapper(7);let a3 = a1.add(2);let a4 = a2.add(new IntWrapper(3));a3.print();a4.print();a5=a5+1
--   </pre>
--   
--   Due to no type checker, you can add two variables of different typing
--   and assign it to another type. In this case, we add a voiid type
--   variable to a boolean variable and assign it to an int variable. This
--   is undefined behavior because the runtime is dependent on the
--   javascript runtime.
--   
--   <pre>
--   INPUT:
--   let a: Boolean = true;
--   let x: Int = 10;
--   let y: Int = 20;
--   let fup: Void = theWhiler(x, y);
--   let goo: Void = theL();
--   fup;
--   goo;
--   y=a+fup;
--   
--   OUTPUT:
--   let a = true;let x = 10;let y = 20;let fup = theWhiler(x,y);let goo = theL();fup;goo;y=a+fup; 
--   </pre>
--   
--   A cool feature of our language is its ability to ignore comments,
--   thanks to a tokenizer that’s designed to skip over them. This allows
--   programmers to include comments in the source language for clarity,
--   while the compiled output is clean and free of comments, ensuring
--   execution without the clutter.
--   
--   <pre>
--   removeComments :: String -&gt; String
--   removeComments [] = []
--   removeComments (<a>/</a> : <a>/</a> : rest) = removeComments (dropWhile (/= 'n') rest)
--   removeComments (keep : check) = keep : removeComments check
--   </pre>
--   
--   In this code it first pattern matches for a "//" and then drops until
--   it sees the new line character. One obvious limitation edge case would
--   be multiple line comments/End of line comments which could be fairly
--   easy to add looking for if its looks for /* and the end */ but at that
--   moment we thought based on this being quirk and the time factor we
--   decided to just keep it as is.
--   
--   <h2>Why this language, and why this language design?</h2>
--   
--   <ul>
--   <li><b>William</b>: "I would say that I thought it would be easy
--   seeing as I worked mostly with javascript since that was the target
--   language but didn't expect how different Haskell would be to code it
--   in."</li>
--   <li><b>Sebastian</b>: "I was mostly interested in the meta language,
--   because I’ve never really touched a functional language, and seeing
--   that the compiler was written in Haskell really intrigued me. It
--   definitely is a very interesting language, and doing nothing but
--   JavaScript and Java for the past two years really did wear me down
--   from Object-Oriented languages. Don’t get me wrong, megaparsec is a
--   really, really handy library for creating a parser, but I just want to
--   try a functional language rather than stick with Java or
--   JavaScript."</li>
--   <li><b>Angel</b>: "It seemed fun and I wanted to work with Haskell. I
--   was interested in the functional programming paradigm and it seemed
--   like a great way to get a deep dive into how it worked. The idea
--   behind TypeClasses and ADT is novel to me and it reduced a bunch of
--   boilerplate."</li>
--   <li><b>Bilin</b>: "Honestly, Haskell wouldn't have been my first
--   choice, but since everyone else wanted to use it, I decided to go with
--   the flow. Looking back now, it actually seems like one of the easier
--   languages to implement a compiler in; thanks to features like pattern
--   matching and the fact that it's not OOP, we're basically able to do
--   each part of the compiler in one file. The main reason we chose this
--   language design is that, after selecting Haskell, this was pretty much
--   the only project that actually referenced Haskell."</li>
--   </ul>
--   
--   <h2>What kind of problems might this language solve, and why was it
--   designed this way?</h2>
--   
--   Hasgull is designed for front-end projects, due to the target language
--   being JavaScript. Its goal was to emulate TypeClasses allowing methods
--   to be reused across various types. Time constraints meant that the
--   generics, ADT, and recursive types aspects were omitted. As a result,
--   the intended TypeClass system ended up resembling Java interfaces but
--   for a specific group of Types and Structs. The language enforces that
--   those implementing Traits must write a method for that type.
--   
--   This method enforcement increases code performance and predictability.
--   By bringing types to JavaScript and enforcing this Trait system,
--   JavaScript benefits from monomorphic optimizations, which can improve
--   performance. In addition, enforcing proper implementations makes the
--   code less error-prone and more predictable.
--   
--   <h2>Known limitations</h2>
--   
--   <ul>
--   <li><b>Lack of typechecking</b><ul><li>No real typechecker exists
--   beyond verifying if a trait has been implemented for a given `impl
--   prog def`.</li><li>Example: `let x: Boolean = true;` followed by `y =
--   x * 2;` is valid syntax from the compiler’s perspective, but the
--   output JavaScript might not behave as the programmer
--   intends.</li><li>The compiler does not verify type correctness beyond
--   trait implementation.</li></ul></li>
--   </ul>
--   
--   <ul>
--   <li><b>No runtime variable initialization checks:</b><ul><li>The
--   compiler doesn't track whether a variable (like identifier i in the
--   AST) was initialized during code generation.</li><li>Due to time
--   constraints, scaffolding for variable tracking wasn't
--   implemented.</li></ul></li>
--   <li><b>Limited primitive types:</b><ul><li>Only three primitive data
--   types are supported.</li><li>There are no character or string
--   primitives.</li></ul></li>
--   <li><b>Poor higher-order function support:</b><ul><li>Although parsing
--   for higher-order functions exists, the syntax is awkward and not
--   recommended for use.</li></ul></li>
--   <li><b>No native support for arrays or lists:</b><ul><li>No support
--   for arrays or lists:</li></ul></li>
--   </ul>
--   
--   <h2>Knowing what you know now, what would you do differently?</h2>
--   
--   <ul>
--   <li><b>William</b>: Knowing what I know now, I would rather choose a
--   different meta language than Haskell. Having Javascript as the target
--   language did make it easier since I knew it quite well. It's just that
--   working with a functional language instead of an object oriented
--   language really threw me for a loop. I would also change the way our
--   group had worked on the project so that we were a bit more organized
--   since they way we did it was more like just asking if anyone has
--   worked on/ is working on something and trying to figure out what isn’t
--   being worked on. It wasn’t a bad way of doing the project. I just
--   would have just preferred a more organized approach. Everything else
--   was fine, we had no real problems with github or our choice of
--   development tool. I was using visual studio code for the entire
--   project and I had no real problems with it.</li>
--   <li><b>Sebastian</b>: One big thing honestly would be to put a more
--   critical eye towards our productions because our current productions
--   are traitor-like. When we started working on the tokenizer and parser,
--   we ended up adding extra symbols and statements simply because it felt
--   strange not to have things like a greater-than operator or a for-loop
--   I feel that in terms of the higher order type, we probably couldn’t do
--   different grammar just so that it could better be translated, because
--   it’s such a weird format in comparison to the other types that we
--   couldn't fully get it operational.Keep the target language, because
--   honestly it did somewhat make the translation part a bit easier
--   because we could just convert statements and expressions straight into
--   the javascript equivalent. Plus, with javascript being dynamically
--   typed, and allowing for weird expressions like add a boolean and
--   integer together, it somewhat was like a typechecker. For the
--   communication, I think it was fine, we first just talked about how we
--   were going to implement each phase and then in those phases, we said
--   what parts were going to be done. We would have a bounty board where
--   someone says they will do the parsing for types, or statements, or
--   defining our tokens</li>
--   <li><b>Angel</b>: At first, I had trouble with our development
--   environment, but I managed to power through it. The linter didn’t work
--   well, so I kept running into indenting issues that held me back at
--   certain times. I should have fixed or addressed it early on because it
--   would have gotten rid of something I did not have to think about. The
--   target language being JavaScript was a good choice because, besides
--   the Trait and Implementation details it was pretty much a one-to-one
--   in terms of transferring it over. The communication was fine, but I
--   think we should have followed your initial advice and split into
--   groups of 2 people per section. At certain points, 2 would have been
--   enough to fulfill certain aspects of the project and would have
--   increased our productivity. I think we could have been better about
--   sharing resources and the overall goal of the language. We learned as
--   we went along</li>
--   <li><b>Bilin</b>: Knowing what I know now, I would have approached the
--   project task assignment differently. Starting work well before the
--   deadline would have helped avoid the time crunch we faced. Our
--   approach was to set up a task board and let team members choose what
--   they wanted to work on, but a more structured method of assigning
--   tasks might have improved our workflow, especially since I believe
--   some people did more than others. I wouldn’t change much about the
--   development tools we used, but one thing I wish we had tried was
--   implementing a bottom-up parser (which we did try to implement with
--   happy but had to scrap it for megaparser) which uses grammars
--   reduction as the foundation. From what I’ve read, it tends to be
--   faster and could have optimized our parser. As for the target
--   language, I chose JavaScript because it's not strictly
--   object-oriented, which made generating the output code simpler. Plus,
--   most members of the group were already familiar with it. However, Rust
--   might have been a better choice in terms of language features, since
--   it supports some OOP-like constructs such as struct and impl. That
--   said, we had limited experience with Rust, which would have made
--   building a compiler that targets it much more challenging.</li>
--   </ul>
--   
--   <h1>An explanation of the state of your compiler </h1>
--   
--   The compiler itself works pretty much 95%. While we don’t have any
--   typechecker, and the higher order type couldn’t really make the cut
--   for code generation(We don’t have enough time honestly to create a
--   special case for it in the generator, and looking at our syntax for
--   function definitions, I’m not really sure how to best translate it-
--   Sebastian). Our tokenizer, parser, and generator work. You can go
--   stack build to build it, then do stack exec Hasgull-exe input.gull
--   outputName and it will compile that code in the input.gull into a
--   <i>outputName.js</i> file with equivalent javascript code.
--   
--   <h1>Information about what you've learned on the project</h1>
--   
--   <ul>
--   <li><b>William</b>: This project taught me alot on how coding
--   languages can vary and how they run things behind the scenes. I was
--   also able to learn about haskell due to this project which I probably
--   never would have learned on my own. I learned how a small thing like
--   basic arithmetic needed to be structured so that it can be properly
--   done in code. As someone who is interested in math I plan to learn
--   more about functional programming languages and how different they are
--   compared to object oriented programming languages.</li>
--   <li><b>Sebastian</b>: This project was pretty much my sole experience
--   learning haskell, which while strange, is honestly quite a neat
--   language. The megaparsec library too, which is a really robust library
--   for creating parsers that was really useful for us. For the code
--   generation portion, a lot of it was learning just how to best
--   translate into javascript, because we did really have to think about
--   how the base language would look in javascript to run how the
--   programmer would run it.</li>
--   <li><b>Angel</b>:This project taught me a lot about the process of
--   building a compiler as well as benefits of different programming
--   language paradigms. I learned how to build a Lexor, Parser, and
--   CodeGenerator. The time that can be saved by choosing a language that
--   supports pattern matching and Algebraic Data Types. We did not have to
--   make unnecessary classes. That Decisions have to be made due to time
--   constraints and it can just be blamed on the programmer.</li>
--   <li><b>Bilin</b>: This project, especially the main goal of creating a
--   compiler, taught me a lot. I never realized what a compiler does in
--   the back and this class and project taught me the key components such
--   as Tokenizer, Parser, Type Checker (I created a mock-up but didn’t
--   have enough time to fully implement it), and Code Generator. Using
--   Haskell for the first time was challenging. It was difficult to
--   understand certain concepts without relying on example code or using
--   AI tools to explain things. Despite the initial learning curve, our
--   team was happy with the decision to use Haskell. It allowed us to
--   avoid unnecessary classes which we often saw in the class examples. At
--   one point, we considered making the output from the Code Generator
--   more human-readable. However, we realized that the purpose of a
--   compiler is to generate output for machines to understand, not humans.
--   Because of that, we decided to keep what we have and drop any further
--   plans for “readable code”. Overall, this project came with a steep
--   learning curve, but it was worth it. I even got to learn how to use
--   GitHub Pages and GitHub Actions to automate the build documentation
--   and updating/publishing for the site.</li>
--   </ul>
module Docs.FAQ


-- | This module provides a formal syntax definition for Hasgull in an
--   extended EBNF-style notation. Copy and paste the following definitions
--   as a reference.
--   
--   <h2>Formal Syntax Definition</h2>
--   
--   <h3>Types and Identifiers</h3>
--   
--   <ul>
--   <li><b>var</b> Represents a variable.</li>
--   <li><b>structname</b> Represents the name of a struct.</li>
--   <li><b>traitname</b> Represents the name of a trait (typeclass).</li>
--   <li><b>i</b> Represents an integer.</li>
--   </ul>
--   
--   <h3>Concrete Syntax</h3>
--   
--   <pre>
--   <b>comma_type</b> ::= [type (`,` type)*]
--   </pre>
--   
--   <pre>
--   <b>type</b> ::=
--            <a>Int</a> | <tt>Void</tt> | <tt>Boolean</tt> | <i>Built-in types</i>
--            <tt>Self</tt> | <i>Refers to our own type in a trait</i>
--            structname | <i>Structs are a valid kind of type</i>
--            `(` type `)` | <i>Parenthesized type</i>
--            `(` comma_type `)` `=&gt;` type <i>Higher-order function</i>
--   </pre>
--   
--   <pre>
--   <b>param</b> ::= var <tt>:</tt> type
--   </pre>
--   
--   <pre>
--   <b>comma_param</b> ::= [param (`,` param)*]
--   </pre>
--   
--   <pre>
--   <b>structdef</b> ::= <tt>struct</tt> structname `{` comma_param `}`
--   </pre>
--   
--   <pre>
--   <i>Definition of an abstract method</i>
--   <b>abs_methoddef</b> ::= <tt>method</tt> var (` comma_param `)` <tt>:</tt> type `;`
--   </pre>
--   
--   <pre>
--   <i>Definition of a concrete method</i>
--   <b>conc_methoddef</b> ::= <tt>method</tt> var (` comma_param `)` <tt>:</tt> type `{` stmt* `}`
--   </pre>
--   
--   <pre>
--   <i>Definition of a trait (typeclass)</i>
--   <b>traitdef</b> ::= <tt>trait</tt> traitname `{` abs_methoddef* `}`
--   </pre>
--   
--   <pre>
--   <i>Definition of an implementation of a typeclass</i>
--   <b>impldef</b> ::= <tt>impl</tt> traitname <tt>for</tt> type `{` conc_methoddef* `}`
--   </pre>
--   
--   <pre>
--   <i>Definition of a toplevel function</i>
--   <b>funcdef</b> ::= <tt>func</tt> var `(` comma_param `)` <tt>:</tt> type `{` stmt* `}` 
--   </pre>
--   
--   <pre>
--   <b>stmt</b> ::= 
--            `let` param `=` exp `;` | <i>Variable declaration</i>
--            var `=` exp `;` | <i>Assignment</i>
--            `if` `(` exp `)` stmt [`else` stmt] | <i>if</i>
--            <tt>while</tt> `(` exp `)` stmt | <i>while</i>
--            <a>break</a> `;` | <i>break</i>
--            <tt>println</tt> `(` exp `)` | <i>Printing something</i>
--            `{` stmt* `}` | <i>Block</i>
--            <a>return</a> [exp] `;` | <i>Return</i>
--            exp `;` <i>Expression statements</i>
--   </pre>
--   
--   <pre>
--   <b>struct_actual_param</b> ::= var <tt>:</tt> exp
--   </pre>
--   
--   <pre>
--   <b>struct_actual_params</b> ::= [struct_actual_param (`,` struct_actual_param)*]
--   </pre>
--   
--   <pre>
--   <b>primary_exp</b> ::= 
--                    i | var | <i>Integers and variables</i>
--                    <tt>true</tt> | <tt>false</tt> | <i>Booleans</i>
--                    <tt>self</tt> | <i>Instance on which we call a method</i>
--                    `(` exp `)` | <i>Parenthesized expression</i>
--   
--                    <i>Creates a new instance of a struct</i>
--                    <tt>new</tt> structname `{` struct_actual_params `}`
--   </pre>
--   
--   <pre>
--   <i>Accessing a struct field or method</i>
--   <b>dot_exp</b> ::= primary_exp (<a>.</a> var)*
--   </pre>
--   
--   <pre>
--   <b>call_exp</b> ::= dot_exp (`(` comma_exp `)`)*
--   </pre>
--   
--   <pre>
--   <b>mult_exp</b> ::= call_exp ((<a>*</a> | <a>/</a>) call_exp)*
--   </pre>
--   
--   <pre>
--   <b>add_exp</b> ::= mult_exp ((<a>+</a> | <a>-</a>) mult_exp)*
--   </pre>
--   
--   <pre>
--   <b>less_than_exp</b> ::= add_exp [<a>&lt;</a> add_exp]
--   </pre>
--   
--   <pre>
--   <b>equals_exp</b> ::= less_than_exp [(<a>==</a> | <tt>!=</tt>) less_than_exp]
--   </pre>
--   
--   <pre>
--   <b>exp</b> ::= equals_exp
--   </pre>
--   
--   <pre>
--   <b>program_item</b> ::= structdef | traitdef | impldef | funcdef
--   </pre>
--   
--   <pre>
--   <b>program</b> ::= program_item* stmt* stmt* is the entry point
--   </pre>
module Docs.FormalSyntax


-- | This module defines the core AST data types used in Hasgull.
module Parser.AST

-- | The <a>Expr</a> data type represents expressions in the Hasgull
--   language.
data Expr

-- | A variable or identifier.
Identifier :: String -> Expr

-- | An integer literal.
Int :: Int -> Expr

-- | Handles True
Trueish :: Expr

-- | Handles False
Falseish :: Expr

-- | Creates a new struct instance.
NewStruct :: Type -> [StructActualParam] -> Expr

-- | Negation of an expression.
Negative :: Expr -> Expr

-- | Addition of two expressions.
Add :: Expr -> Expr -> Expr

-- | Field or method access.
DotExpr :: Expr -> Expr -> Expr

-- | Function or method call.
Call :: Expr -> [Expr] -> Expr

-- | Subtraction of two expressions.
Sub :: Expr -> Expr -> Expr

-- | The special <tt>self</tt> keyword.
LowerSelf :: Expr

-- | Multiplication of two expressions.
Multiply :: Expr -> Expr -> Expr

-- | Division of two expressions.
Division :: Expr -> Expr -> Expr

-- | Equality comparison.
Equals :: Expr -> Expr -> Expr

-- | Inequality comparison.
NotEquals :: Expr -> Expr -> Expr

-- | Greater-than comparison.
GreaterThan :: Expr -> Expr -> Expr

-- | Less-than comparison.
LessThan :: Expr -> Expr -> Expr

-- | The <a>Type</a> data type represents types in the Hasgull language.
data Type

-- | The integer type.
IntType :: Type

-- | The void type.
VoidType :: Type

-- | The boolean type.
BooleanType :: Type

-- | The special <tt>Self</tt> type.
SelfType :: Type

-- | A named struct type.
StructName :: String -> Type

-- | A higher-order function type with parameter types and a return type.
HigherOrderType :: [Type] -> Type -> Type

-- | The <a>Param</a> data type represents parameters (for functions or
--   declarations) with a name and type.
data Param

-- | A parameter with a name and an associated type.
Param :: String -> Type -> Param

-- | The <a>Stmt</a> data type represents statements in the Hasgull
--   language.
data Stmt

-- | Variable declaration with initialization.
LetStmt :: Param -> Expr -> Stmt

-- | Assignment of an expression to a variable.
AssgStmt :: Expr -> Expr -> Stmt

-- | While-loop; executes a statement while the condition holds.
WhileStmt :: Expr -> Stmt -> Stmt

-- | For-loop with initialization, condition, update, and body.
ForStmt :: Stmt -> Expr -> Stmt -> Stmt -> Stmt

-- | If-statement with an optional else clause.
IfStmt :: Expr -> Stmt -> Maybe Stmt -> Stmt

-- | Break out of a loop.
BreakStmt :: Stmt

-- | Print an expression to the console.
PrintLnStmt :: Expr -> Stmt

-- | A block of statements.
BlockStmt :: [Stmt] -> Stmt

-- | Return statement with an optional expression.
ReturnStmt :: Maybe Expr -> Stmt

-- | An expression used as a statement.
ExprStmt :: Expr -> Stmt

-- | The <a>Program</a> data type represents an entire Hasgull program.
data Program
Program :: [ProgramItem] -> [Stmt] -> Program

-- | Top-level program items such as struct, trait, or function
--   definitions.
[progItems] :: Program -> [ProgramItem]

-- | Top-level statements.
[progStmts] :: Program -> [Stmt]

-- | The <a>ProgramItem</a> data type represents items that can appear at
--   the top level in a program.
data ProgramItem

-- | A struct definition.
PI_Struct :: StructDef -> ProgramItem

-- | A trait (typeclass) definition.
PI_Trait :: TraitDef -> ProgramItem

-- | An implementation of a trait.
PI_Impl :: ImplDef -> ProgramItem

-- | A function definition.
PI_Func :: FuncDef -> ProgramItem

-- | The <a>TraitDef</a> data type represents a trait (or typeclass)
--   definition.
data TraitDef
TraitDef :: String -> [AbsMethodDef] -> TraitDef

-- | The name of the trait.
[traitName] :: TraitDef -> String

-- | The abstract methods declared by the trait.
[traitAbsMethodDef] :: TraitDef -> [AbsMethodDef]

-- | The <a>AbsMethodDef</a> data type represents an abstract method
--   definition within a trait.
data AbsMethodDef
AbsMethodDef :: String -> [Param] -> Type -> AbsMethodDef

-- | The name of the abstract method.
[abMethName] :: AbsMethodDef -> String

-- | The parameters of the method.
[abMethParameters] :: AbsMethodDef -> [Param]

-- | The return type of the method.
[abMethReturnType] :: AbsMethodDef -> Type

-- | The <a>StructDef</a> data type represents a struct definition.
data StructDef
StructDef :: String -> [Param] -> StructDef

-- | The name of the struct.
[strucName] :: StructDef -> String

-- | The fields of the struct.
[strucFields] :: StructDef -> [Param]

-- | The <a>ImplDef</a> data type represents an implementation of a trait
--   for a specific type.
data ImplDef
ImplDef :: String -> Type -> [ConcMethodDef] -> ImplDef

-- | The name of the trait being implemented.
[implTraitName] :: ImplDef -> String

-- | The type for which the trait is implemented.
[iForType] :: ImplDef -> Type

-- | The concrete method definitions that implement the trait.
[iMethods] :: ImplDef -> [ConcMethodDef]

-- | The <a>ConcMethodDef</a> data type represents a concrete method
--   definition.
data ConcMethodDef
ConcMethodDef :: String -> [Param] -> Type -> [Stmt] -> ConcMethodDef

-- | The name of the concrete method.
[cmName] :: ConcMethodDef -> String

-- | The parameters for the method.
[cmParameters] :: ConcMethodDef -> [Param]

-- | The return type of the method.
[cmReturnType] :: ConcMethodDef -> Type

-- | The body of the method, expressed as a list of statements.
[cmBody] :: ConcMethodDef -> [Stmt]

-- | The <a>FuncDef</a> data type represents a top-level function
--   definition.
data FuncDef
FuncDef :: String -> [Param] -> Type -> [Stmt] -> FuncDef

-- | The function name.
[funcName] :: FuncDef -> String

-- | The parameters of the function.
[funcParameters] :: FuncDef -> [Param]

-- | The return type of the function.
[funcReturnType] :: FuncDef -> Type

-- | The function body as a list of statements.
[funcBody] :: FuncDef -> [Stmt]

-- | The <a>StructActualParam</a> data type represents an actual parameter
--   used when creating a struct instance.
data StructActualParam

-- | A field initialization with a field name and an expression.
StructActualParam :: String -> Expr -> StructActualParam
instance GHC.Classes.Eq Parser.AST.AbsMethodDef
instance GHC.Classes.Eq Parser.AST.ConcMethodDef
instance GHC.Classes.Eq Parser.AST.Expr
instance GHC.Classes.Eq Parser.AST.FuncDef
instance GHC.Classes.Eq Parser.AST.ImplDef
instance GHC.Classes.Eq Parser.AST.Param
instance GHC.Classes.Eq Parser.AST.Program
instance GHC.Classes.Eq Parser.AST.ProgramItem
instance GHC.Classes.Eq Parser.AST.Stmt
instance GHC.Classes.Eq Parser.AST.StructActualParam
instance GHC.Classes.Eq Parser.AST.StructDef
instance GHC.Classes.Eq Parser.AST.TraitDef
instance GHC.Classes.Eq Parser.AST.Type
instance GHC.Classes.Ord Parser.AST.Expr
instance GHC.Classes.Ord Parser.AST.Param
instance GHC.Classes.Ord Parser.AST.Stmt
instance GHC.Classes.Ord Parser.AST.StructActualParam
instance GHC.Classes.Ord Parser.AST.Type
instance GHC.Show.Show Parser.AST.AbsMethodDef
instance GHC.Show.Show Parser.AST.ConcMethodDef
instance GHC.Show.Show Parser.AST.Expr
instance GHC.Show.Show Parser.AST.FuncDef
instance GHC.Show.Show Parser.AST.ImplDef
instance GHC.Show.Show Parser.AST.Param
instance GHC.Show.Show Parser.AST.Program
instance GHC.Show.Show Parser.AST.ProgramItem
instance GHC.Show.Show Parser.AST.Stmt
instance GHC.Show.Show Parser.AST.StructActualParam
instance GHC.Show.Show Parser.AST.StructDef
instance GHC.Show.Show Parser.AST.TraitDef
instance GHC.Show.Show Parser.AST.Type

module Generation.EnvTable

-- | <a>buildTraitTable</a> constructs a table of trait signatures from a
--   list of program items.
--   
--   It traverses the program items and, for every trait definition
--   (wrapped in <a>PI_Trait</a>), inserts an entry mapping the trait's
--   name to its list of abstract methods.
buildTraitTable :: [ProgramItem] -> TraitTable

-- | <a>TraitTable</a> is a mapping from a trait name to its list of
--   abstract methods.
type TraitTable = Map String [AbsMethodDef]


-- | This section of the module is responsible for emitting JavaScript code
--   for methods and translating program items (such as struct,
--   implementation, and function definitions) into their corresponding
--   JavaScript representations.
module Generation.Generation

-- | generateJS: Converts a Program AST to JavaScript.
generateJS :: Program -> String
translateFuncDef :: FuncDef -> String
translateBlock :: [Stmt] -> String

-- | Translate a Stmt AST node into a string of an equivalent javascript
--   expression
translateStmt :: Stmt -> String

-- | translate an Type AST node into a string of an equivalent javascript
--   expression
translateType :: Type -> String

-- | Translate a Param AST node into a string of an equivalent javascript
--   expression
translateParam :: Param -> String

-- | Translate an expression AST node into a string of an equivalent
--   javascript expression
translateExpr :: Expr -> String

-- | Test function to see if we can write the output of a generateJS to a
--   test javascript file
createOutputFile :: Program -> String -> IO String

-- | Translate a StructActualParam AST node into a string of an equivalent
--   javascript expression
translateStructParam :: StructActualParam -> String

-- | Translates a StructDef AST node into a string of an equivalent
--   javascript
translateFunc :: FuncDef -> String

-- | <a>translateImpl</a> translates an implementation definition
--   (<a>ImplDef</a>) into its
translateImpl :: TraitTable -> ImplDef -> String

-- | <a>translateItem</a> translates a top-level program item
--   (<a>ProgramItem</a>) into its JavaScript equivalent. Depending on the
--   type of program item it dispatches to the appropriate translation
--   function.
translateItem :: TraitTable -> ProgramItem -> String

-- | Wraps a block statement in curly braces
wrapBlock :: Stmt -> String

-- | Indent Helper function
indent :: Int -> String -> String

-- | Helper function for the assgStmt in the For Loop
translateIterForLoop :: Stmt -> String

-- | <a>TraitTable</a> is a mapping from a trait name to its list of
--   abstract methods.
type TraitTable = Map String [AbsMethodDef]


-- | This module defines the Token data type and its constructors which
--   represent the different tokens recognized by the tokenizer of the
--   Hasgull programming language.
module Tokenizer.Token

-- | The <a>Token</a> data type defines all tokens recognized by the
--   Hasgull language. These tokens are used during lexical analysis to
--   represent keywords, operators, punctuation, and other language
--   elements.
data Token

-- | Represents the <a>==</a> operator.
EqualsToken :: Token

-- | Represents the '=' operator.
EqualToken :: Token

-- | Represents the <tt>!=</tt> operator.
NotEqualToken :: Token

-- | Represents the <a>&gt;</a> operator.
GreaterThanToken :: Token

-- | Represents the <a>&lt;</a> operator.
LessThanToken :: Token

-- | Represents the <a>+</a> operator.
AddToken :: Token

-- | Represents the <a>-</a> operator.
SubtractToken :: Token

-- | Represents the <a>*</a> operator.
MultiplyToken :: Token

-- | Represents the <a>/</a> operator.
DivideToken :: Token

-- | Represents the '('.
LParenToken :: Token

-- | Represents the ')'.
RParenToken :: Token

-- | Represents the '{'.
LBraceToken :: Token

-- | Represents the '}'.
RBraceToken :: Token

-- | Represents the ','.
CommaToken :: Token

-- | Represents the <tt>:</tt>.
ColonToken :: Token

-- | Represents the '=&gt;' operator.
ArrowToken :: Token

-- | Represents the ';'.
SemiColonToken :: Token

-- | Represents the <a>.</a>.
DotToken :: Token

-- | Represents the <a>Int</a> keyword.
IntToken :: Token

-- | Represents the <tt>Void</tt> keyword.
VoidToken :: Token

-- | Represents the <tt>Boolean</tt> keyword.
BooleanToken :: Token

-- | Represents the 'if' keyword.
IfToken :: Token

-- | Represents the 'else' keyword.
ElseToken :: Token

-- | Represents the <tt>while</tt> keyword.
WhileToken :: Token

-- | Represents the <a>return</a> keyword.
ReturnToken :: Token

-- | Represents the <tt>println</tt> keyword.
PrintLnToken :: Token

-- | Represents the <tt>func</tt> keyword.
FuncToken :: Token

-- | Represents the <tt>true</tt> literal.
TrueToken :: Token

-- | Represents the <tt>false</tt> literal.
FalseToken :: Token

-- | Represents the <tt>Self</tt> keyword.
SelfToken :: Token

-- | Represents the <tt>self</tt> keyword.
LowerCaseSelfToken :: Token

-- | Represents the <tt>method</tt> keyword.
MethodToken :: Token

-- | Represents the <a>break</a> keyword.
BreakToken :: Token

-- | Represents the <tt>impl</tt> keyword.
ImplToken :: Token

-- | Represents the 'let' keyword.
LetToken :: Token

-- | Represents the <tt>trait</tt> keyword.
TraitToken :: Token

-- | Represents the <tt>new</tt> keyword.
NewToken :: Token

-- | Represents the <tt>for</tt> keyword.
ForToken :: Token

-- | Represents the <tt>struct</tt> keyword.
StructToken :: Token

-- | Represents an integer literal.
IntegerToken :: Int -> Token

-- | Represents an identifier.
IdentifierToken :: String -> Token

-- | Represents the name of a structure.
StructNameToken :: String -> Token
instance GHC.Classes.Eq Tokenizer.Token.Token
instance GHC.Classes.Ord Tokenizer.Token.Token
instance GHC.Show.Show Tokenizer.Token.Token


-- | This module provides parsers for expressions, types, parameters,
--   statements, and program structures used in the Hasgull language. It
--   also includes parsers for trait, struct, implementation, and function
--   definitions.
module Parser.Parser

-- | Parser type alias for a token stream using Megaparsec.
type Parser = Parsec Void [Token]

-- | Parse a comma-separated list of expressions.
pCommaExp :: Parser [Expr]

-- | Parse a function or method call expression.
pCallExp :: Parser Expr

-- | Parse a variable reference (identifier) as an expression.
pVariable :: Parser Expr

-- | Predicate to determine if a token is an identifier.
isIdentifierToken :: Token -> Bool

-- | Parse an integer literal.
pInteger :: Parser Expr

-- | Predicate to determine if a token is an integer.
isIntegerToken :: Token -> Bool

-- | Parse a struct instantiation expression.
pNewStruct :: Parser Expr

-- | Check that a token matches the expected token.
checkMatchingToken :: Token -> Parser Token

-- | Parse an atomic expression including parentheses, identifiers,
--   integers, booleans, or struct instantiation.
pAtom :: Parser Expr

-- | Parse an expression enclosed in parentheses.
pParensAtom :: Parser Expr

-- | Parse a return statement.
pReturnStmt :: Parser Stmt

-- | Parse a print statement.
pPrintLnStmt :: Parser Stmt

-- | Parse a type literal. Tries the function type parser first; on
--   failure, falls back to parsing an atomic type.
pType :: Parser Type

-- | Parse an atomic type.
pAtomType :: Parser Type

-- | Parse a higher-order (function) type.
pFunctionType :: Parser Type

-- | Parse a comma-separated list of argument types.
pArgType :: Parser [Type]

-- | Parse the integer type.
pIntType :: Parser Type

-- | Parse the void type.
pVoidType :: Parser Type

-- | Parse the boolean type.
pBooleanType :: Parser Type

-- | Parse the <tt>Self</tt> type.
pSelfType :: Parser Type
pStructname :: Parser Type

-- | Parse a parenthesized type.
pParenType :: Parser Type

-- | Parse a parameter.
pParam :: Parser Param

-- | Parse a comma-separated list of parameters.
pCommaParam :: Parser [Param]

-- | Parse a single parameter.
pAtomParam :: Parser Param

-- | Parse a let statement.
pLetStmt :: Parser Stmt

-- | Parse an assignment statement.
pAssgStmt :: Parser Stmt

-- | Parse an assignment statement without a trailing semicolon.
pAssgStmtSemiLess :: Parser Stmt

-- | Parse an expression used as a statement.
pExprStmt :: Parser Stmt

-- | Parse a break statement.
pBreakStmt :: Parser Stmt

-- | Parse a block of statements.
pBlockStmt :: Parser Stmt

-- | Parse a while statement.
pWhileStmt :: Parser Stmt

-- | Parse a for loop statement.
pForStmt :: Parser Stmt

-- | Parse any statement.
pStmt :: Parser Stmt

-- | Parse a boolean literal.
pBoolean :: Parser Expr

-- | Parse the <tt>self</tt> expression.
pSelf :: Parser Expr
pTrue :: Parser Expr
pFalse :: Parser Expr
pParens :: Parser Expr

-- | Parse an if statement.
pIfStmt :: Parser Stmt

-- | Parse an else or else-if block.
pElseOrElseIf :: Parser Stmt

-- | Parse a condition expression.
pCondition :: Parser Expr

-- | Parse an expression followed by a semicolon (used in conditions).
pPainandMisery :: Parser Expr

-- | Parse a condition enclosed in parentheses.
pParensCondition :: Parser Expr

-- | Parses a conditional term expression in the following order from top
--   to bottom:
condTerm :: Parser Expr

-- | Operator table for condition expressions.
condOperatorTable :: [[Operator Parser Expr]]

-- | Parse a term expression (either a call expression or a single term).
pTerm :: Parser Expr

-- | Parse a single term expression.
pSingleTerm :: Parser Expr

-- | Parse an expression.
pExpr :: Parser Expr
operatorTable :: [[Operator Parser Expr]]

-- | Helper for binary operators.
binary :: Token -> (Expr -> Expr -> Expr) -> Operator Parser Expr

-- | Helper for prefix operators.
prefix :: Token -> (Expr -> Expr) -> Operator Parser Expr

-- | Parse a specific token.
symbol :: Token -> Parser Token

-- | Parse an expression from a list of tokens.
parseExpression :: [Token] -> Either (ParseErrorBundle [Token] Void) Expr

-- | Parse a type from a list of tokens.
parseType :: [Token] -> Either (ParseErrorBundle [Token] Void) Type

-- | Parse a parameter from a list of tokens.
parseParam :: [Token] -> Either (ParseErrorBundle [Token] Void) Param

-- | Parse a statement from a list of tokens.
parseStmt :: [Token] -> Either (ParseErrorBundle [Token] Void) Stmt

-- | Parse a TraitDef from a list of tokens.
pTraitDef :: [Token] -> Either (ParseErrorBundle [Token] Void) TraitDef

-- | Parse an AbsMethodDef from a list of tokens.
pAbsMethodDef :: [Token] -> Either (ParseErrorBundle [Token] Void) AbsMethodDef

-- | Parse a StructDef from a list of tokens.
pStructDef :: [Token] -> Either (ParseErrorBundle [Token] Void) StructDef

-- | Parse an ImplDef from a list of tokens.
pImplDef :: [Token] -> Either (ParseErrorBundle [Token] Void) ImplDef

-- | Parse a ConcMethodDef from a list of tokens.
pConcMethodDef :: [Token] -> Either (ParseErrorBundle [Token] Void) ConcMethodDef

-- | Parse a top-level function definition from a list of tokens.
pFuncDef :: [Token] -> Either (ParseErrorBundle [Token] Void) FuncDef

-- | Parse a ProgramItem from a list of tokens.
pProgramItem :: [Token] -> Either (ParseErrorBundle [Token] Void) ProgramItem

-- | Parse an entire Program from a list of tokens.
pProgram :: [Token] -> Either (ParseErrorBundle [Token] Void) Program

-- | check if Identifier <a>token</a> for struct name.
pIdentifier :: Parser String

-- | Parse a struct name.
pAtomStructActualParam :: Parser StructActualParam

-- | Parse a single struct actual parameter.
pStructActualParam :: Parser StructActualParam

-- | Parse a comma-separated list of struct actual parameters.
pStructActualParams :: Parser [StructActualParam]

-- | Parse a trait definition.
parseTraitDef :: Parser TraitDef

-- | Parse an abstract method definition.
parseAbsMethodDef :: Parser AbsMethodDef

-- | Parse a struct definition.
parseStructDef :: Parser StructDef

-- | Parse an implementation definition.
parseImplDef :: Parser ImplDef

-- | Parse a concrete method definition.
parseConcMethodDef :: Parser ConcMethodDef

-- | Parse a function definition.
parseFuncDef :: Parser FuncDef

-- | Parse a top-level program item.
parseProgramItem :: Parser ProgramItem

-- | Parse an entire program consisting of program items and statements.
parseProgram :: Parser Program


-- | This module provides functionality to tokenize input source code by
--   removing comments and whitespace, then converting the input into a
--   list of tokens as defined in <a>Token</a>.
module Tokenizer.Tokenizer

-- | Tokenize the input string into a list of tokens.
--   
--   This function removes comments and whitespace before invoking the
--   tokenization of individual components.
tokenize :: String -> Either String [Token]

-- | Strip whitespace from the input string and return a list of words.
--   
--   Uses the built-in <a>words</a> function to split the input on
--   whitespace.
stripWhiteSpace :: String -> [String]

-- | Remove line comments from the input.
--   
--   Cool gimmick we wanted to include in our compiler to be able add
--   comments to our code. Line comments begin with "//" and continue until
--   the end of the line.
removeComments :: String -> String

-- | Remove leading whitespace from a string.
--   
--   Drops any space characters (<a>isSpace</a>) from the beginning of the
--   input.
removeLeadingWhiteSpace :: String -> String

-- | Determine if an identifier string corresponds to a reserved word, or
--   should be treated as a generic identifier.
--   
--   Recognized reserved words include <a>Int</a>, <a>Void</a>, "if",
--   "else", etc. Any identifier not matching these is returned as an
--   IdentifierToken.
tryReadIdentifierOrReservedWord :: String -> Token

-- | Attempt to read a multi-character symbol from the input.
--   
--   Recognized multi-character symbols include: * "=&gt;" becomes
--   ArrowToken * "==" becomes EqualsToken * "!=" becomes NotEqualToken
--   
--   Returns a tuple of the matching token and the remaining input string,
--   or Nothing if no match.
tryReadMultiCharSymbol :: String -> Maybe (Token, String)

-- | Attempt to read a symbol token from a single character.
--   
--   Converts characters such as '=' and <a>+</a> into their corresponding
--   token variants. Returns Nothing if the character is not a recognized
--   symbol.
tryReadSymbolToken :: Char -> Maybe Token

-- | Determine if the remaining part of a numerical literal is valid.
--   
--   A leftover is invalid if it starts with an alphabetic character,
--   indicating an error.
validLeftOver :: String -> Bool

-- | Tokenize a list of whitespace-stripped words into tokens.
--   
--   Processes each word and concatenates the results.
tokenizeStrippedWords :: [String] -> Either String [Token]

-- | Recursively tokenizes a single string into a list of tokens.
--   
--   Continues processing until the string is fully consumed.
tokenizationLoop :: String -> Either String [Token]

-- | Extract the next token from the input string.
--   
--   Selects the correct handler based on the first character, whether it's
--   alphabetic, numeric, or a symbol.
nextToken :: String -> Either String (Token, String)

-- | Handle an identifier or reserved word.
--   
--   Collects alphanumeric characters and returns a token corresponding to
--   either a reserved word or an identifier.
handleIdentifierOrReserveWord :: Char -> String -> Either String (Token, String)

-- | Handle a numeric literal from the input.
--   
--   Reads consecutive digits and checks for invalid trailing characters.
handleNumber :: Char -> String -> Either String (Token, String)

-- | Handle symbols from the input string.
--   
--   First attempts to match multi-character symbols, then falls back to
--   single-character symbol matching.
handleSymbol :: String -> Either String (Token, String)
